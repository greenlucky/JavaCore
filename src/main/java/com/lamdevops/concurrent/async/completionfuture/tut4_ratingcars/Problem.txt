1. Now that the functionality of CompletionStage and specifically CompletableFuture is explored, the below example applies them in a practical scenario:
2. First fetch a list of Car objects asynchronously by calling the cars() method, which returns a CompletionStage<List>. The cars() method could be consuming a remote REST endpoint behind the scenes.
3. We then compose another CompletionStage<List> that takes care of filling the rating of each car, by calling the rating(manufacturerId) method which returns a CompletionStage that asynchronously fetches the car rating (again could be consuming a REST endpoint).
4. When all Car objects are filled with their rating, we end up with a List<CompletionStage>, so we call allOf() to get a final stage (stored in variable done) that completes upon completion of all these stages. Using whenComplete() on the final stage, we print the Car objects with their rating.
Since the Car instances are all independent, getting each rating asynchronously improves performance. Furthermore, waiting for all car ratings to be filled is done using a more natural allOf() method, as opposed to manual thread waiting (e.g. using Thread#join() or a CountDownLatch).