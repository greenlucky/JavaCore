Now you don’t have to scan the loop for evidence of filtering and counting. The method names tell you right away what the code intends to do.
Streams follow the “what, not how” principle. In our stream example, we describe what needs to be done: get the long words and count them. We don’t specify in which order, or in which thread, this should happen. In contrast, the loop at the beginning of this section specifies exactly how the computation should work, and thereby forgoes any chances of optimization.
A stream seems superficially similar to a collection, allowing you to transform and retrieve data. But there are significant differences:
1. A stream does not store its elements. They may be stored in an underlying collection or generated on demand.
2. Stream operations don’t mutate their source. For example, the filter method does not remove elements from a new stream, but it yields a new stream in which they are not present.
3. Stream operations are lazy when possible. This means they are not executed until their result is needed. For example, if you only ask for the first five long words instead of all, the filter method will stop filtering “after the fifth match. As a consequence, you can even have infinite streams!
Let us have another look at the example. The stream and parallelStream methods yield a stream for the words list. The filter method returns another stream that contains only the words of length greater than twelve. The count method reduces that stream to a result.
This workflow is typical when you work with streams. You set up a pipeline of operations in three stages:
In our example, the stream was created with the stream or parallelStream method. The filter method transformed it, and count was the terminal operation.
In the next section, you will see how to create a stream. The subsequent three sections deal with stream transformations. They are followed by five sections on terminal operations.
Now you don’t have to scan the loop for evidence of filtering and counting. The method names tell you right away what the code intends to do.
Streams follow the “what, not how” principle. In our stream example, we describe what needs to be done: get the long words and count them. We don’t specify in which order, or in which thread, this should happen. In contrast, the loop at the beginning of this section specifies exactly how the computation should work, and thereby forgoes any chances of optimization.
A stream seems superficially similar to a collection, allowing you to transform and retrieve data. But there are significant differences:
1. A stream does not store its elements. They may be stored in an underlying collection or generated on demand.
2. Stream operations don’t mutate their source. For example, the filter method does not remove elements from a new stream, but it yields a new stream in which they are not present.
3. Stream operations are lazy when possible. This means they are not executed until their result is needed. For example, if you only ask for the first five long words instead of all, the filter method will stop filtering “after the fifth match. As a consequence, you can even have infinite streams!
Let us have another look at the example. The stream and parallelStream methods yield a stream for the words list. The filter method returns another stream that contains only the words of length greater than twelve. The count method reduces that stream to a result.
This workflow is typical when you work with streams. You set up a pipeline of operations in three stages:
In our example, the stream was created with the stream or parallelStream method. The filter method transformed it, and count was the terminal operation.
In the next section, you will see how to create a stream. The subsequent three sections deal with stream transformations. They are followed by five sections on terminal operations.
Now you don’t have to scan the loop for evidence of filtering and counting. The method names tell you right away what the code intends to do.
Streams follow the “what, not how” principle. In our stream example, we describe what needs to be done: get the long words and count them. We don’t specify in which order, or in which thread, this should happen. In contrast, the loop at the beginning of this section specifies exactly how the computation should work, and thereby forgoes any chances of optimization.
A stream seems superficially similar to a collection, allowing you to transform and retrieve data. But there are significant differences:
1. A stream does not store its elements. They may be stored in an underlying collection or generated on demand.
2. Stream operations don’t mutate their source. For example, the filter method does not remove elements from a new stream, but it yields a new stream in which they are not present.
3. Stream operations are lazy when possible. This means they are not executed until their result is needed. For example, if you only ask for the first five long words instead of all, the filter method will stop filtering “after the fifth match. As a consequence, you can even have infinite streams!
Let us have another look at the example. The stream and parallelStream methods yield a stream for the words list. The filter method returns another stream that contains only the words of length greater than twelve. The count method reduces that stream to a result.
This workflow is typical when you work with streams. You set up a pipeline of operations in three stages:
In our example, the stream was created with the stream or parallelStream method. The filter method transformed it, and count was the terminal operation.
In the next section, you will see how to create a stream. The subsequent three sections deal with stream transformations. They are followed by five sections on terminal operations.
Now you don’t have to scan the loop for evidence of filtering and counting. The method names tell you right away what the code intends to do.
Streams follow the “what, not how” principle. In our stream example, we describe what needs to be done: get the long words and count them. We don’t specify in which order, or in which thread, this should happen. In contrast, the loop at the beginning of this section specifies exactly how the computation should work, and thereby forgoes any chances of optimization.
A stream seems superficially similar to a collection, allowing you to transform and retrieve data. But there are significant differences:
1. A stream does not store its elements. They may be stored in an underlying collection or generated on demand.
2. Stream operations don’t mutate their source. For example, the filter method does not remove elements from a new stream, but it yields a new stream in which they are not present.
3. Stream operations are lazy when possible. This means they are not executed until their result is needed. For example, if you only ask for the first five long words instead of all, the filter method will stop filtering “after the fifth match. As a consequence, you can even have infinite streams!
Let us have another look at the example. The stream and parallelStream methods yield a stream for the words list. The filter method returns another stream that contains only the words of length greater than twelve. The count method reduces that stream to a result.
This workflow is typical when you work with streams. You set up a pipeline of operations in three stages:
In our example, the stream was created with the stream or parallelStream method. The filter method transformed it, and count was the terminal operation.
In the next section, you will see how to create a stream. The subsequent three sections deal with stream transformations. They are followed by five sections on terminal operations.
Now you don’t have to scan the loop for evidence of filtering and counting. The method names tell you right away what the code intends to do.
Streams follow the “what, not how” principle. In our stream example, we describe what needs to be done: get the long words and count them. We don’t specify in which order, or in which thread, this should happen. In contrast, the loop at the beginning of this section specifies exactly how the computation should work, and thereby forgoes any chances of optimization.
A stream seems superficially similar to a collection, allowing you to transform and retrieve data. But there are significant differences:
1. A stream does not store its elements. They may be stored in an underlying collection or generated on demand.
2. Stream operations don’t mutate their source. For example, the filter method does not remove elements from a new stream, but it yields a new stream in which they are not present.
3. Stream operations are lazy when possible. This means they are not executed until their result is needed. For example, if you only ask for the first five long words instead of all, the filter method will stop filtering “after the fifth match. As a consequence, you can even have infinite streams!
Let us have another look at the example. The stream and parallelStream methods yield a stream for the words list. The filter method returns another stream that contains only the words of length greater than twelve. The count method reduces that stream to a result.
This workflow is typical when you work with streams. You set up a pipeline of operations in three stages:
In our example, the stream was created with the stream or parallelStream method. The filter method transformed it, and count was the terminal operation.
In the next section, you will see how to create a stream. The subsequent three sections deal with stream transformations. They are followed by five sections on terminal operations.
Now you don’t have to scan the loop for evidence of filtering and counting. The method names tell you right away what the code intends to do.
Streams follow the “what, not how” principle. In our stream example, we describe what needs to be done: get the long words and count them. We don’t specify in which order, or in which thread, this should happen. In contrast, the loop at the beginning of this section specifies exactly how the computation should work, and thereby forgoes any chances of optimization.